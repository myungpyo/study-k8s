쿠버네티스 엔진이란 무엇인가?  
젠킨스란 무엇인가?  
CI/CD란 무엇인가?  
우리에게 어떤 이로움을 줄 수 있는가?  
이번 랩은 앞서 배운 3개의 강의를 종합하여 이러한 물음에 답하는 랩 입니다.  

문서는 아래 링크에서 볼 수 있습니다.
https://github.com/myungpyo/study-k8s
랩에서는 젠킨스와 스피너커가 두 종류로 설명하고 있어서 두종류 다 번역 및 실습 진행해 보았습니다.

마지막이니만큼 이 랩에서 설명하고 있는 기술을 가상의 사례로 표현해 보고는 방식을 취하고,
실습 과정에 대한 설명은 앞서 드린 링크 문서로 갈음 하고자 합니다. (사실 잘 모르겠어서 이런 방식을 ㄷ ㄷ ㄷ)


개발을 진행하면서 CI/CD 라는 용어를 접하곤 합니다.
CI는 지속적 통합(Continuous Integration)을 CD는 지속적 배포(Continuous Deployment)를 뜻 합니다.
어떤 서비스를 개발할 때 우리는 dev -> stage -> real 등의 방식으로 그 개발 단계를 나누게 되고(Phase),
이 단계 안에서 각 개발자의 변경 사항을 지속적으로 검증하고 통합해 나가며 언제든 배포 가능한 버전을 유지해 나갑니다.
그렇기 때문에 최신의 업데이트 된 버전을 늘 서비스 할 수 있는 환경이 됩니다.

그런데 위와 같은 일은 손으로 직접하기엔 번거롭고 실수의 우려도 있습니다.
이런 곤란한 상황을 해결해주기 위해 사용할 수 있는 도구로 
CI 를 위해서 젠킨스나 스피너커 등이 있고, 
CD를 위해 쿠버네티스나 도커스웜 등이 있습니다.

최근에는 모바일 앱 개발에서도 CI 를 위해 젠킨스나 트레비스등을 많이 사용하므로 익숙할 것입니다.
젠킨스에 빌드 파이프라인(빌드 준비, 빌드, 테스트, 패키징, 배포 등등)을 구성하고 코드가 업데이트 되면 파이프라인을 동작시킵니다.

쿠버네티스는 오픈소스 컨테이너 오케스트레이션 기술입니다. 컨테이너를 관리해주는 플랫폼이라고 생각하면 될 것 같습니다.
구글이 자사 플랫폼(GCP)에서 제공하는 쿠버네티스 상용 제품의 이름이 "쿠버네티스 엔진" 입니다.
앞서 이야기 한 것처럼 쿠버네티스는 컨테이너 오케스트레이션 기술이기 때문에 쿠버네티스의 이점을 누리려면 애플리케이션을 컨테이너로 만들어야 합니다.
이것을 컨테이너화(Containerization) 한다고 합니다.
그리고 이렇게 컨테이너화 된 애플리케이션은 쿠버네티스 엔진에서 Pod에 올라가 서비스되며, 서비스가 되지 않는 동안은 리소스를 점유하지 않습니다.


그래서 이 기술을 쓰면 먹고사는데 나아지나요?
해서 다음과 같은 상황을 가정해 보며 생각해보았습니다. 일부러 극적으로 만들었습니다.ㅇㅅㅇ;;;

우리팀은 InssaService 1.0 을 서비스하고 있는 중인데 UX 개편 프로젝트가 떠서 2.0을 만들기로 했습니다. -_-; (참고로 인싸이더들만 쓰는 서비스 입니다.ㅋㅋ)
우리는 지금 CI/CD 따위는 신경쓸 겨를이 없습니다. 역시 사람이 한땀한땀 손으로 하는게 제맛입니다.
열심히 2.0 스펙을 dev 환경에서 개발했고, 개발된 사항이 QA 가능한 수준까지 도달하여 stage 환경에서 QA가 이루어 진다고 합니다.
그런데 QA 와 동시에 유관 부서에서 도그푸딩 형식으로 체험판을 업데이트 받아 쓰고 싶다고 합니다.
우리는 QA 와 도그푸딩 환경을 분리하고 싶기 때문에 기존엔 1대였던 stage 서버를 두개로 가져가기로 했습니다.
사장님께 부탁해서 깡통 서버 한대를 추가로 할당받아 동일하게 stage 환경 설정을 하고 stage 버전의 애플리케이션을 설치했습니다.
이번 패치에는 다른 의존 라이브러리가 추가되어 그것도 두 서버 모두 설치해 줘야 합니다.

애플리케이션 개발 및 검증이 완료되었고, 사장님이 만족해 합니다. 새로운 버전을 배포할 준비가 끝났습니다.
현재 버전 1.0은 10개의 물리 서버로 서비스 하고 있는 상황입니다.
이번 2.0은 데이터 형식이 바뀌어 한대씩 점진적으로 업데이트 할 상황이 아닙니다.
어쩔 수 없이 2시간 서비스 정지 후 배포를 하기로 합니다.
한대 ~ 한대 ~ 배포를 해나가는데 개발팀에서 치명적인 오류가 있다고 멈춰 달라고 합니다.
배포 하던 것들을 롤백하고 기다립니다.
개발팀에서 수정을 완료하고 최신 브랜치에서 배포를 계속 해도 된다고 합니다.
고객과 약속한 2시간이 다되어 갑니다. 고객님들께 1시간 지연된다고 노티합니다.
다시 한대~ 한대~ 패치해 나갑니다. 
드디어 패치 완료. 서비스 시작!
아악! 인기가 너무 좋습니다. 사용자가 몰려옵니다. 서버가 버텨내질 못합니다.
사장님이 서버를 사준다고 얼른 추가하라고 합니다.
이건 클릭으로 되는게 아닌데요? -ㅅ-
울며 잠이 듭니다.


위와 같은 상황을 젠킨스와 쿠버네티스 기술을 사용하는 팀은 어떻게 해결하고 있을까요?
1.0 버전 애플리케이션은 이미 컨테이너화 되어 쿠버네티스로 서비스 중입니다.
이렇게 만든 컨테이너는 고유의 이름과 버전 태그를 갖게 되므로 다음과 같이 버저닝되어 컨테이너 레지스트리에 등록되어 있습니다.
(구글이 운영하는 컨테이너 레지스트리는 GCR 입니다.)
InssaService v1.0.0
InssaService v1.0.1
InssaService v1.0.2
...

2.0.0 버전의 개발이 시작되었습니다. 개발자가 Git 을 이용하여 Pull request(PR) 를 할때마다 젠킨스가 빌드 오류는 없는지, 코드 퀄리티는 괜찮은지 신경써줍니다.
다른 개발자들도 PR을 보고 괜찮다고 썸즈업! 해주고 develop 브랜치에 머지를 허락해 줍니다.
우리는 인싸 개발팀이기 때문에 야근이란 없습니다. 모두 퇴근합니다.
새벽 3시 젠킨스가 일어납니다. develop 브랜치 빌드할 시간이군! 
develop 브랜치 빌드를 시작합니다.
빌드 이상이 없음을 확인하고 테스트를 진행합니다. 테스트도 OK 입니다.
정적 분석도 진행하여 개발자들에게 리포트 해놓습니다.
이제 develop 브랜치의 산출물을 컨테이너로 만듭니다. 
개발자기 친절하게 어떤 컨테이너로 만들어 달라고 하는건지 Dockerfile 에 기술해 놓았습니다.
컨테이너 버전을 v2.0.0-rc2 처럼 rc버전을 하나씩 올려서 쿠버네티스 stage 환경에 배포합니다.
현재 쿠버네티스에 InssaService의 stage 환경을 위한 Pod 이 1개 있습니다.

아침이 되어 개발자들은 일상처럼 작업을 이어갑니다.
QA 부서는 새로 배포된 버전을 아침에 확인하고 QA 활동을 이어나갑니다.
stage 버전으로 사내 도그푸딩도 한다고 합니다. QA와 환경이 섞이면 안되어 별도 서버로 만들어야 한다고 합니다.
상관 없습니다. scale up 하여 Pod을 2개로 만들고 하나는 qa 로 태깅하고 다릉 하나는 dogfooding으로 태깅하고 서비스 합니다.
이제 기존 Pod을 포함하여 두개의 Pod은 InssaService v2.0.0-rc2를 stage 모드로 서비스 하고 있습니다.
이번 버전에는 다른 의존 라이브러리가 추가됐다고 하지만 상관 없습니다. 어차피 의존성은 컨테이너 v2.0.0-rc2에 함께 명시되어 있기 때문에 Pod만 Node에 잘 서비스 되면 됩니다.
사장님이 만족스럽다고 하네요. 배포 준비가 끝났습니다. 버전에서 rc를 떼고 최종 Git에 커밋하고 master branch 로 머지합니다.

master branch를 항상 지켜보고 있던 젠킨스가 master branch가 변경된 것을 알았습니다.
오우! 리얼 배포 할시간!!
신나게 v2.0.0 앱을 빌드합니다. 그리고 혹시 모르니 개발자들이 짜놓은 테스트코드로 테스트도 해봅니다.
신규 버전 v2.0.0 을 컨테이너 레지스트리에 올립니다.
헌재 실서비스되고 있는 replica set은 10개의 컨테이너를 사용중입니다.
이번 배포는 데이터 스키마 변경이 있어 롤링 업데이트는 안된다고 합니다.
블루-그린 업데이트로 가닥을 잡습니다.
10개의 Pod을 추가로 띄워 v2.0.0을 서비스 하도록 합니다.
완료되고나면 로드밸런서가 모든 트래픽을 v2.0.0으로 돌리도록 합니다.
기존 Pod은 모두 종료합니다.
아악 인기가 너무 좋습니다! 사용자가 몰려옵니다. GCP 에서 경고 알람이 옵니다.
얼른 Maximum pod 10개 더 늘려줍니다. 총 20개 pod입니다. 다행히 이제 잘 버텨냅니다.
퇴근 후 웃으며 잠이 듭니다.

덧,
기획자가 오더니 엄청 멋진 신기능이 있는데... 아는 개발자를 꼬셔 구현까지도 하긴 했는데 사용자가 좋아할지 찔러보기만 하고 싶다고 합니다.
A/B 테스트 하자는 이야기 입니다.
몇% 사용자 정도 생각하냐고 했더니 10% 정도 해보고 싶다고 합니다.
현재 20게 pod을 사용중이니 2개 pod을 추가하고 2개 pod에는 canary 로 태깅합니다.
canary pod은 기존 container + patch 된 버전의 컨테이너를 서비스 합니다.
사용자 반응이 좋으면 다음 버전에 추가하고, 좋지않으면 그냥 버립니다.








